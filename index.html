<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>可攜式連結記事簿</title>
</head>
<body>
  <!-- ... 省略 UI 部分，保留之前完整版本 ... -->

  <script>
  // ====== GitHub 同步（修正版：自動更新 sha 避免 409 Conflict） ======
  async function ghLoad(){
    if(!cfg.owner||!cfg.repo||!cfg.path){ alert('請先到設定填寫 owner/repo/path'); return }
    setStat('從 GitHub 讀取中…');
    const url=`https://api.github.com/repos/${encodeURIComponent(cfg.owner)}/${encodeURIComponent(cfg.repo)}/contents/${encodeURIComponent(cfg.path)}?ref=${encodeURIComponent(cfg.branch||'main')}`;
    const res=await fetch(url,{headers:ghHeaders()});
    if(res.status===404){ if(confirm('遠端檔案不存在，要建立一個新的嗎？（之後請按「存到 GitHub」）')){ state.items=[]; saveLocal(); renderTable(); return } else { setStat('已取消'); return } }
    if(!res.ok){ const t=await res.text(); alert('讀取失敗：'+res.status+'\n'+t); return }
    const json=await res.json();
    state.ghSha = json.sha; // 記錄最新 sha
    const content = b64DecodeUTF8(json.content||'');
    const data = JSON.parse(content||'{}');
    if(!data || !Array.isArray(data.items)) throw new Error('遠端 JSON 格式不正確');
    state.items = data.items; state.types = Array.isArray(data.types)?data.types:state.types;
    saveLocal(); renderTypes(); renderTable();
    setStat(`已從 GitHub 載入（${cfg.owner}/${cfg.repo}:${cfg.branch||'main'} · ${cfg.path}）`);
  }

  async function ghSave(){
    if(!cfg.owner||!cfg.repo||!cfg.path||!cfg.token){ alert('請先到設定填寫 owner/repo/path 與 PAT'); return }
    setStat('上傳至 GitHub…');

    // 確保有最新 sha（先嘗試讀一次）
    try{ await ghLoad() }catch(e){ /* 若讀不到就繼續用既有資料 */ }

    const payload = { version:1, updatedAt:now(), types:state.types, items:state.items };
    const content = b64EncodeUTF8(JSON.stringify(payload,null,2));
    const url=`https://api.github.com/repos/${encodeURIComponent(cfg.owner)}/${encodeURIComponent(cfg.repo)}/contents/${encodeURIComponent(cfg.path)}`;

    async function putWithSha(sha){
      const body={ message:`chore: update links.json @ ${new Date().toISOString()}`, content, branch: cfg.branch||'main', sha };
      return fetch(url,{ method:'PUT', headers:{...ghHeaders(),'Content-Type':'application/json'}, body:JSON.stringify(body) });
    }

    // 第一次 PUT 嘗試
    let res = await putWithSha(state.ghSha);
    if(res.status===409){
      // 409 衝突：重新抓取最新 sha，再詢問使用者要載入或覆蓋
      const meta = await (await fetch(`${url}?ref=${encodeURIComponent(cfg.branch||'main')}`,{headers:ghHeaders()})).json();
      const remoteContent = meta?.content ? b64DecodeUTF8(meta.content) : '';
      const localContent  = b64DecodeUTF8(content);
      const changed = remoteContent && remoteContent !== localContent;

      const choice = confirm('偵測到 GitHub 上的 data/links.json 已被更新。
按「確定」= 直接覆蓋遠端（使用目前頁面的內容）。
按「取消」= 先載入遠端最新版本。');
      if(!choice){
        // 使用者選擇先載入遠端
        await ghLoad(); setStat('已載入遠端最新版本，請再檢查後儲存。'); return;
      }
      // 使用者選擇覆蓋遠端：以最新 sha 再試一次
      res = await putWithSha(meta?.sha);
    }

    if(!res.ok){ const t=await res.text(); alert('儲存失敗：'+res.status+'
'+t); return }
    const out=await res.json(); state.ghSha = out.content?.sha || undefined;
    setStat('已提交至 GitHub ✅');
  }
  </script>
</body>
</html>
